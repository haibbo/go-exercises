## Exercise

### 2.2:
```
~/c/g/c/2-cf git:master ❯❯❯ ./main 40
40°F = 4.444444444444445°C, 40°C = 104°F
40kg = 88.18490487395103lb, 40lb = 18.143694800000002kg
40″ = 1.016m, 40m = 1574.8031496062993″
~/c/g/c/2-cf git:master ❯❯❯ ./main
50
50°F = 10°C, 50°C = 122°F
50kg = 110.23113109243879lb, 50lb = 22.6796185kg
50″ = 1.27m, 50m = 1968.5039370078741″
```

### 2.3:
```
~/c/g/c/3-popcount git:master ❯❯❯ go test  -bench=.  gopl.io/ch2/popcount
goos: darwin
goarch: amd64
pkg: gopl.io/ch2/popcount
BenchmarkPopCount-4             	2000000000	         0.38 ns/op
BenchmarkPopCountByLoop-4       	10000000	       121 ns/op
BenchmarkPopCountByClearing-4   	50000000	        36.1 ns/op
BenchmarkPopCountByShifting-4   	10000000	       150 ns/op
PASS
ok  	gopl.io/ch2/popcount	5.662s
```

## 命名

- 一个名字必须以一个字母或下划线开头，后面可以跟任意数量的字母、数字或下划线. Go语言是大小写敏感的.

- Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字.

- 预声明的常量, 类型和函数, 如true make int32 等,可以在声明中使用它们

- 如果一个名字是在函数内部定义，那么它的就只在函数内部有效.如果是在函数外部定义，那么将在**当前包的所有文件**中都可以访问.

- 如果一个名字是大写字母开头的, 且它是在函数外部定义的包级名字，那么它将是导出的，也就是说可以被**外部的包**访问.

- Go语言程序员推荐使用 **驼峰式** 命名法

  ​
## 声明
- Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明

- 包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要.

  ​

## 变量
- var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个.
- 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil.
- 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量.
- 它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导.
- 简短变量声明语句中必须至少要声明一个新的变量
- 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将**会在当前词法域重新声明一个新的变量**.
- 一个指针的值是另一个变量的地址.
- 变量有时候被称为可寻址的值.即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作.
- 在Go语言中，返回函数中局部变量的地址也是安全的.
- 将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值
- 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名.
- **如果一个变量无任何别名,也就是无法使用了, 垃圾回收器就会把它回收**
- 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后**返回变量地址**,返回的指针类型为*T.
- 用new创建变量和普通变量声明语句方式创建变量没有什么区别, 它类似于一种语法糖.
- 如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和 [0]int, 有可能有相同的地址
- 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的
- 在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止
- 一个变量的有效周期只取决于是否可达.

## 赋值
- 数值变量也可以支持++递增和--递减语句, 它是语法不是表达式, 不能给别的变量赋值


- 在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值.例, x, y = y, x
- 可以用下划线空白标识符_来丢弃不需要的值
- 类型必须完全匹配
- 对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之依然



## 类型
- 变量或表达式的类型定义了对应存储值的属性特征


- type声明定义了一个新的命名类型, 它和某个已有类型使用同样的底层类型. 但是这个新类型的变量,和底层类型的变量是不能直接比较的.

- 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用.

- 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型

- 只有当**两个类型的底层基础类型相同时，才允许这种转型操作**，或者是两者都是**指向相同底层结构的指针类型**，这些转换只改变类型而不会影响值本身.

- 数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的

- 在任何情况下，运行时不会发生转换失败的错误, 有问题的转换会在编译阶段报出

- 命名类型还可以为该类型的值定义新的行为.这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集.

  ​

## 包和文件
- 目的都是为了支持模块化、封装、单独编译和代码重用.
- 一个包的名字和包的导入路径的最后一个字段相同
- 如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理.
- init初始化函数除了不能被调用或引用外，其他行为和普通函数类似

  ​

## 作用域
- 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性.
- 一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念.
- 当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找. 所以内部的一个声明可能会屏蔽外部的声明
- Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进.
- 加入变量cwd在外部已经声明过，但是if语句内, :=语句还是将cwd和err重新声明为新的局部变量.因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量.

